{
    "collab_server" : "",
    "contents" : "#!/usr/bin/env Rscript \n#Creates a SingleCellExperiment object, which scater's calculateQCMetrics already applied\n# Load optparse we need to check inputs\n\nsuppressPackageStartupMessages(require(optparse))\nsuppressPackageStartupMessages(require(workflowscriptscommon))\nsuppressPackageStartupMessages(require(SingleCellExperiment))\nsuppressPackageStartupMessages(require(scater))\n\n# parse options\n#SCE-specific options\noption_list = list(\n  make_option(\n    c(\"-a\", \"--assays\"),\n    action = \"store\",\n    default = NA,\n    type = 'character',\n    help = \"Comma-separated list of file names specifying tsv-format matrices. All elements of the list must have the same dimensions, and dimension names (if present) must be consistent across elements and with the row names of rowRanges and colData. The first column of all files is assumed to be feature names.\"\n  ),\n  make_option(\n    c(\"-n\", \"--assay-names\"),\n    action = \"store\",\n    default = 'counts',\n    type = 'character',\n    help = \"Comma-separated list of assay names. If this is not specified, and only a single assay is provided, this will be 'counts'. Otherwise assay names will be derived from input files\"\n  ),\n  make_option(\n    c(\"-r\", \"--row-data\"),\n    action = \"store\",\n    default = NULL,\n    type = 'character',\n    help = \"Path to TSV format file describing the features. Row names, if present, become the row names of the SingleCellExperiment.\"\n  ),\n  make_option(\n    c(\"-c\", \"--col-data\"),\n    action = \"store\",\n    default = NULL,\n    type = 'character',\n    help = \"Path to TSV format file describing the samples. Row names, if present, become the column names of the SummarizedExperiment object. The number of rows of the DataFrame must equal the number of rows of the matrices in assays.\"\n  ),\n  make_option(\n    c(\"-s\", \"--spike-names\"),\n    action = \"store\",\n    default = NA,\n    type = 'character',\n    help = \"Path to file containing spike names (column 1) and types (e.g. ERCC, column 2), in TSV format.\"\n  ),\n  #The scater-specific options\n  make_option(\n    c(\"-e\", \"--exprs-values\"),\n    action = \"store\",\n    default = 'counts',\n    type = 'character',\n    help= \"character(1), indicating slot of the 'assays' of the 'object' that should be used to define expression. Valid options are 'counts' [default; recommended],'tpm','fpkm' and 'logcounts', or anything else in the object added manually by the user.\"\n  ),\n  make_option(\n    c(\"-f\", \"--mt-controls\"),\n    action = \"store\",\n    default = NULL,\n    type = 'character',\n    help = \"file containing a list of the control files with one file per line. Each control file should have one feature (e.g. gene) per line. A named list is created (names derived from control file names) containing one or more vectors to identify feature controls (for example, ERCC spike-in genes, mitochondrial genes, etc)\"\n  ),\n  make_option(\n    c(\"-p\", \"--ercc-controls\"),\n    action = \"store\",\n    default = NULL,\n    type = 'character',\n    help = \"file containing a list of the control files with one file per line. Each control file should have one feature (e.g. gene) per line. A named list is created (names derived from control file names) containing one or more vectors to identify feature controls (for example, ERCC spike-in genes, mitochondrial genes, etc)\"\n  ),\n  make_option(\n    c(\"-l\", \"--cell-controls\"),\n    action = \"store\",\n    default = NULL,\n    type = 'character',\n    help = \"file (one cell per line) to be used to derive a vector of cell (sample) names used to identify cell controls (for example, blank wells or bulk controls).\"\n  ),\n  make_option(\n    c(\"-o\", \"--output-object-file\"),\n    action = \"store\",\n    default = NA,\n    type = 'character',\n    help = \"File name in which to store serialized SingleCellExperiment object.\"\n  )\n)\n\nopt <- wsc_parse_args(option_list, mandatory = c('assays', 'output_object_file'))\n\n# Check parameter values\n\nassayfiles <- wsc_split_string(opt$assays)\n\nfor (af in assayfiles){\n  if ( ! file.exists(af) ){\n    stop(paste('File', af, 'does not exist'))\n  }\n}\n\n# Now we're hapy with the arguments, load SingleCellExperiment and do the work\n\n\n# Read the assay data\n\nassays <- lapply(assayfiles, read.delim, row.names = 1)\nassays <- lapply(assays, as.matrix)\n\n# Name the assays\n\nassaynames <- wsc_split_string(opt$assay_names)\nif (length(assays) == length(assaynames)){\n  names(assays) <- assaynames\n}else{\n  names(assays) <- unlist(lapply(assayfiles, function(x) sub(pattern = \"(.*)\\\\..*$\", replacement = \"\\\\1\", basename(x))))\n}\n\n# Read row and column annotations\n\nrowdata <- opt$row_data\n\nif ( ! is.null(opt$row_data) ){\n  rowdata <- read.delim(opt$row_data)\n}\n\ncoldata <- opt$col_data\n\nif ( ! is.null(opt$col_data) ){\n  coldata <- read.delim(opt$col_data)\n}\n\n# Now build the object\n\nsingle_cell_experiment <- SingleCellExperiment( assays = assays, colData = coldata, rowData = rowdata)\nsingle_cell_experiment\n# Define spikes (if supplied)\n\nif ( ! is.na(opt$spike_names) ){\n  \n  if ( ! file.exists(opt$spike_names) ){\n    stop(paste(\"Supplied spikes file\", opt$spike_names, \"does not exist\"))\n  }\n  \n  spike_names <- read.table(opt$spike_names)\n  \n  spikes_by_type <- split(spike_names, spike_names$V2)\n  for ( st in names(spikes_by_type) ){\n    isSpike(single_cell_experiment, st) <- match(spikes_by_type[[st]]$V1, rownames(single_cell_experiment))\n  }\n}\n\n#Scater options\n\n# Check feature_controls (only mitochondrial used for now)\n\nif (! is.null(opt$mt_controls) && opt$mt_controls != 'NULL'){\n  if (! file.exists(opt$mt_controls)){\n    stop((paste('Supplied feature_controls file', opt$mt_controls, 'does not exist')))\n  }else{\n    mt_controls <- readLines(opt$mt_controls)\n\n  }\n}else{\n  mt_controls <- NULL\n}\n\nif (! is.null(opt$ercc_controls) && opt$ercc_controls != 'NULL'){\n  if (! file.exists(opt$ercc_controls)){\n    stop((paste('Supplied feature_controls file', opt$ercc_controls, 'does not exist')))\n  }else{\n    ercc_controls <- readLines(opt$ercc_controls)\n    \n  }\n}else{\n  ercc_controls <- NULL\n}\n\n\n# Check cell_controls\nif (! is.null(opt$cell_controls) && opt$cell_controls != 'NULL'){\n  if (! file.exists(opt$cell_controls)){\n    stop((paste('Supplied feature_controls file', opt$cell_controls, 'does not exist')))\n  }else{\n    cell_controls <- readLines(opt$cell_controls)\n  }\n}else{\n  cell_controls <- NULL\n}\n\n\n# calculate QCMs from raw count matrix\nSingleCellExperiment  <- calculateQCMetrics(single_cell_experiment, exprs_values = opt$exprs_values, feature_controls = list(MT=mt_controls, ERCC=ercc_controls), cell_controls = list(empty = cell_controls))\nSingleCellExperiment\n# Output to a serialized R object\nsaveRDS(SingleCellExperiment, file = opt$output_object_file)\n",
    "created" : 1539248460367.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "477928847",
    "id" : "5EC87BA8",
    "lastKnownWriteTime" : 1539323128,
    "last_content_update" : 1539323128216,
    "path" : "~/projects/single_cell/Galaxy/galaxy_tools/RCode/test_scater/scater_modules_1.8.4/scater-create-qcmetric-ready-sce.R",
    "project_path" : "scater-create-qcmetric-ready-sce.R",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}